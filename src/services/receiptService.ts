
import {
  collection, addDoc, Timestamp, writeBatch, doc, getDoc, updateDoc, query, where, getDocs
} from "firebase/firestore";
import { db } from "@/lib/firebase";
import type {
  Receipt, ReceivedItem, PurchaseOrder, PurchaseOrderDetail, StockMovementType, Warehouse, User as AppUser, ReceiptItemStatus
} from "@/types";
import { getUserById } from "./userService";
import { getWarehouseById } from "./warehouseService";
import { getProductById } from "./productService";
import { recordStockMovement, updateStockItem } from "./stockService";
import { updatePurchaseOrderStatus } from "./purchaseOrderService"; 

export interface CreateReceiptServiceData {
  purchaseOrderId: string;
  receiptDate: Timestamp;
  receivingUserId: string;
  targetWarehouseId: string;
  notes: string;
  itemsToReceive: Array<{ // This is the flat list generated by the page component
    productId: string;
    productName: string; 
    quantityReceived: number; // This is the quantity for THIS specific status entry
    itemStatus: ReceiptItemStatus;
    itemNotes: string; 
    poDetailId: string; // To link back to the specific PO line item
    currentPOReceivedQuantity: number; // Needed to correctly update the PO line
    poOrderedQuantity: number; // For context if needed
  }>;
}

export const createReceipt = async (data: CreateReceiptServiceData): Promise<string> => {
  const batch = writeBatch(db);
  const now = Timestamp.now();

  const receivingUser = await getUserById(data.receivingUserId);
  if (!receivingUser) throw new Error("Receiving user not found.");

  const targetWarehouse = await getWarehouseById(data.targetWarehouseId);
  if (!targetWarehouse || !targetWarehouse.isActive) {
    throw new Error("Target warehouse not found or is inactive.");
  }

  const poRef = doc(db, "purchaseOrders", data.purchaseOrderId);
  const poSnap = await getDoc(poRef);
  if (!poSnap.exists()) throw new Error("Purchase Order not found.");
  const purchaseOrder = { id: poSnap.id, ...poSnap.data() } as PurchaseOrder;


  const receiptRef = doc(collection(db, "receipts"));
  const receiptData: Omit<Receipt, "id" | "receivedItems" | "receivingUserName" | "targetWarehouseName"> = {
    purchaseOrderId: data.purchaseOrderId,
    receiptDate: data.receiptDate,
    receivingUserId: data.receivingUserId,
    targetWarehouseId: data.targetWarehouseId,
    notes: data.notes,
    createdAt: now,
    updatedAt: now,
    createdBy: data.receivingUserId,
  };
  batch.set(receiptRef, receiptData);

  // Keep track of total quantities physically received per PO detail line for this receipt
  const physicalReceiptsForPODetail: Record<string, number> = {};

  for (const item of data.itemsToReceive) {
    const product = await getProductById(item.productId); 
    if (!product || !product.isActive) {
      throw new Error(`Product ${item.productName} (ID: ${item.productId}) is not valid or active for receipt.`);
    }

    const receivedItemRef = doc(collection(receiptRef, "receivedItems"));
    const receivedItemData: Omit<ReceivedItem, "id"> = {
      productId: item.productId,
      productName: product.name, 
      quantityReceived: item.quantityReceived, // This is the specific qty for THIS status (e.g. 5 "Ok", or 0 for "Missing")
      itemStatus: item.itemStatus,
      notes: item.itemNotes,
    };
    batch.set(receivedItemRef, receivedItemData);

    // Only update stock for items that are physically received and affect inventory counts
    if (item.quantityReceived > 0 && (item.itemStatus === "Ok" || item.itemStatus === "Damaged" || item.itemStatus === "Other")) {
      const { quantityBefore, quantityAfter } = await updateStockItem(
        item.productId,
        data.targetWarehouseId,
        item.quantityReceived, 
        data.receivingUserId,
        batch 
      );

      await recordStockMovement({
          productId: item.productId,
          productName: product.name,
          warehouseId: data.targetWarehouseId,
          warehouseName: targetWarehouse.name,
          type: 'INBOUND_PO',
          quantityChanged: item.quantityReceived,
          quantityBefore,
          quantityAfter,
          movementDate: data.receiptDate,
          userId: data.receivingUserId,
          userName: receivingUser.displayName || data.receivingUserId,
          reason: `PO Receipt: ${data.purchaseOrderId.substring(0,8)}...`,
          notes: `Item: ${product.name}. Qty: ${item.quantityReceived}. Status: ${item.itemStatus}. ${item.itemNotes || ''}`.trim(),
          relatedDocumentId: data.purchaseOrderId,
          supplierId: purchaseOrder.supplierId,
        },
        batch 
      );
      
      // Aggregate physical receipts for this PO detail line
      physicalReceiptsForPODetail[item.poDetailId] = (physicalReceiptsForPODetail[item.poDetailId] || 0) + item.quantityReceived;
    }
  }
  
  // Update receivedQuantity on each PO detail based on aggregated physical receipts
  for (const poDetailId in physicalReceiptsForPODetail) {
    if (physicalReceiptsForPODetail.hasOwnProperty(poDetailId)) {
      const poItemFromRequest = data.itemsToReceive.find(i => i.poDetailId === poDetailId);
      if (poItemFromRequest) {
        const poDetailRef = doc(db, `purchaseOrders/${data.purchaseOrderId}/details/${poDetailId}`);
        const newTotalReceivedForPOItem = poItemFromRequest.currentPOReceivedQuantity + physicalReceiptsForPODetail[poDetailId];
        batch.update(poDetailRef, { receivedQuantity: newTotalReceivedForPOItem });
      }
    }
  }
  
  batch.update(poRef, { updatedAt: now });

  await batch.commit();
  return receiptRef.id;
};

async function getPODetailsForStatusCheck(poId: string): Promise<PurchaseOrderDetail[]> {
    const detailsCollectionRef = collection(db, `purchaseOrders/${poId}/details`);
    const snapshot = await getDocs(query(detailsCollectionRef)); // No specific order needed for this check
    return snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() } as PurchaseOrderDetail));
}

export async function updatePOStatusAfterReceipt(purchaseOrderId: string, userId: string) {
    const poRef = doc(db, "purchaseOrders", purchaseOrderId);
    const poSnap = await getDoc(poRef);
    if (!poSnap.exists()) {
        console.error(`PO ${purchaseOrderId} not found during status update after receipt.`);
        return;
    }

    const purchaseOrder = { id: poSnap.id, ...poSnap.data() } as PurchaseOrder;
    const details = await getPODetailsForStatusCheck(purchaseOrderId); // Fetches current state of PO details

    if (details.length === 0 && (!purchaseOrder.details || purchaseOrder.details.length === 0)) {
        // PO has no line items at all. Mark as completed if not already.
        if (purchaseOrder.status !== "Completed" && purchaseOrder.status !== "Canceled") {
            await updatePurchaseOrderStatus(purchaseOrderId, "Completed", userId);
        }
        return;
    }
     if (details.length === 0 && purchaseOrder.details && purchaseOrder.details.length > 0) {
        // This case indicates an issue, likely details subcollection was not populated correctly
        // or there's a mismatch. Log a warning and potentially set to PartiallyDelivered if appropriate.
        console.warn(`PO ${purchaseOrderId} has no details in subcollection for status check, but parent doc might imply details. Status might be incorrect. Current status: ${purchaseOrder.status}`);
        if (purchaseOrder.status !== "PartiallyDelivered" && purchaseOrder.status !== "Completed" && purchaseOrder.status !== "Canceled") {
           await updatePurchaseOrderStatus(purchaseOrderId, "PartiallyDelivered", userId);
        }
        return;
    }

    let allItemsFullyReceived = true;

    for (const detail of details) {
        if ((detail.receivedQuantity || 0) < detail.orderedQuantity) {
            allItemsFullyReceived = false;
            break; 
        }
    }

    let newStatus: PurchaseOrderStatus;

    if (allItemsFullyReceived) {
        newStatus = "Completed";
    } else { 
        newStatus = "PartiallyDelivered"; // If any item is not fully received
    }
    
    if (newStatus !== purchaseOrder.status) {
        await updatePurchaseOrderStatus(purchaseOrderId, newStatus, userId);
    } else {
        // If status doesn't change, still update the `updatedAt` timestamp directly for consistency.
        await updateDoc(poRef, { updatedAt: Timestamp.now() });
    }
}

    
